<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>拉曼查酿心人剧评</title>
    <link href="/2020/12/25/%E6%8B%89%E6%9B%BC%E6%9F%A5%E9%85%BF%E5%BF%83%E4%BA%BA/"/>
    <url>/2020/12/25/%E6%8B%89%E6%9B%BC%E6%9F%A5%E9%85%BF%E5%BF%83%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/26/sA1recgftJ7VuX6.jpg" alt="d4fd92bd8104c4b6c99d7c0c67930ae"></p><p>第一次去看这种环境话剧,一开始还很期待环境话剧的演出形式.  不像是观众在台下,演员在台上的那种传统演出形式.  演员和观众有了更多的互动, 观众也随着演出的转场而移步换景, 好像剧中的故事真的就发生在自己周围, 沉浸感十足.</p><p>拉曼查是西班牙的葡萄酒产区,故事也主要发生在这个地方. 辛雨追寻男朋友路涛的脚步来到了西班牙,然而却和路涛产生了矛盾. 后来房东姐姐过来安慰辛雨,并帮她安排了在拉曼查采摘葡萄的”高薪工作”. 其实在这里就可以大概猜出路涛的退缩可能就是因为房东丽娜. 后来,辛雨来到拉曼查,邂逅了罗蒙,在拉曼查的生活让辛雨逐渐和过去的自己和解,和路涛和解. 葡萄酿酒,拉曼查酿心. 最后辛雨接受了罗蒙的追求,留在了西班牙,留在了拉曼查.</p><p><img src="https://i.loli.net/2020/12/26/vrfkxd6uq29bwIz.jpg" alt="b9c42b5aeaf3d86d81416418b69437d"></p><p>故事比较简单,其中的许多细节都很用心.比如现场的环境布置, 跟着演员一起走过他们在马德里的屋子,坐着前往拉曼查的火车,到拉曼查的酒庄,都有一种身临其境的感觉. 其中一幕是观众隔着窗户和百叶窗在看,虽然听不到演员的对白,我站的比较靠后也没看到他们在屋子里发生了什么.但这就给观众一种置身其中而又旁观的感觉.还有在从马德里到拉曼查的路上,手电筒的光打在积木上,手电筒缓缓移动,在墙上打出火车行进的光影,特别惊喜.中间还穿插的很多的吉他,钢琴演奏还有歌舞.虽然我不太喜欢太多的歌舞元素,可能还是比较喜欢讲故事多一点吧.</p><p>ps: clickhouse在圣诞节的彩蛋,后面应该会写clickhouse的内容啦.</p><p>Happy new year.</p><p><img src="https://i.loli.net/2020/12/26/vioFQObKH5h7S3N.png" alt="f83fca24b7371cd9d257914514c3ebf"></p>]]></content>
    
    
    
    <tags>
      
      <tag>戏剧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用命令(3)</title>
    <link href="/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(3)/"/>
    <url>/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(3)/</url>
    
    <content type="html"><![CDATA[<p>这次主要写一些数学相关的东西.</p><hr><p>在LaTeX中最常用到的就是文本模式和数学模式.数学模式又分为行内公式和行间公式两种.</p><p>简单来说,行内公式就是将数学式子写在文本行中,与文本融为一体,适用于比较简单的式子,比如说: <img src="https://www.zhihu.com/equation?tex=a%5E2+b%5E2=c%5E2" alt="[公式]"> .</p><p>而行间公式是将数学式插在文本行之间,自成一行.适用于较复杂的式子.</p><p>行内公式的三种形式</p><ul><li>$…….$</li><li>(…….)</li><li>\begin{math}……..\end{math}</li></ul><p>排版效果都相同,我一般使用第一种方法.</p><p>行间公式的三种形式</p><ul><li>$$……..$$</li><li>[……….]</li><li>\begin{displaymath}…..\end{displaymath}</li></ul><p>排版效果都相同,我一般使用第一种或第二种方法.</p><p>除此之外,还可以使用equation公式环境,会自动生成带序号的行间公式.</p><p>数学相关的宏包比较多,一般来说,公式宏包amsmath和字符宏包amssymb是最常用的.</p><p><strong>常用数学符号</strong></p><p>这里偷个懒,用一下刘海样老师的《LaTeX入门》中整理的数学符号。</p><p><img src="https://pic1.zhimg.com/80/v2-ccda495fa31337b40f2621cc43f91234_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-57501edad60547ac7caeedde28649960_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-42210e5e4377b1a88983b254c506327a_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-710f0732753a1b2226612ede151bcdf3_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-c588ef9e531c12e3fc0cda3ca9884875_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-d59db9aaa09c749eb6cf54e2f8e0def3_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-e8d8c9a5dfb8ebae49a285a424aea0d2_720w.jpg" alt="img"></p><p>同时如果遇到不会打的符号可以通过<a href="http://detexify.kirelabs.org/classify.html">这个</a>网站手写查询。</p><p>\boldmath 用来加粗数学符号，如向量。需用在数学模式之外。例：\boldmath$\alpha$</p><p>斜体大写希腊字母：\mathnormal</p><p>粗斜体希腊字母：\boldsymbol</p><p>空心大写字母：\mathbb</p><p>公式中如果需要文字可以使用\text{文字}，将文字插入公式中。</p><p>\frac 与\dfrac</p><p>\frac生成的公式会在高度上压缩，\dfrac可以避免这个问题。</p><p>实例图如下</p><p><img src="https://pic1.zhimg.com/80/v2-baf4a635dee001d47e0fcd15af6be6d8_720w.jpg" alt="img"></p><p>上下标：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\sum_&#123;i=1&#125;^&#123;n&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-be129ea3fea5f7b44f600cba5203c507_720w.jpg" alt="img"></p><p>多行上下标：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$\lim\limits_&#123;\substack&#123;P\to P_0\\P\in D&#125;&#125;f(P)=f(P_0)$$<br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-82cb750d832ad886665b9a0afe7e31f5_720w.jpg" alt="img"></p><p>数学中的表格环境之前有介绍到，这里就不重复了。<a href="https://zhuanlan.zhihu.com/p/35041879">LaTeX-我的常用命令(2)</a></p><p>定理环境：</p><p>需要先使用定义定理类环境的命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\newtheorem&#123;环境名&#125;[]&#123;标题&#125;[]<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">\newtheorem&#123;defi&#125;&#123;定义&#125;<br>\begin&#123;defi&#125;<br>$a^2+b^2=c^2$<br>\end&#123;defi&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-4dd330bed972976bb98583e69c17c940_720w.jpg" alt="img"></p><p>数学模式中的空白</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">\quad<br>\qquad<br>\,%大小约为3/18个\quad<br>\;%5/18\quad<br>\:%4/18\quad可用于对空白的控制<br></code></pre></td></tr></table></figure><p>自适应的放大命令</p><p>可根据内容自动放大括号</p><p>示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">\left(\drac&#123;\frac ab +c&#125;&#123;d&#125;\right)<br>%如果只出现左半边括号，也需要在另一端加\right.<br></code></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-f0b53419bc0f01609f5507debf855cf6_720w.jpg" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用命令(2)</title>
    <link href="/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(2)/"/>
    <url>/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(2)/</url>
    
    <content type="html"><![CDATA[<p>这是第二篇,主要写一下表格,列表,图的内容,还有上次没写到的参考文献.</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>LaTeX提供了无表格框线环境tabbing和有表格框线的tabular,tabular*,array,其中array是用于数学模式的表格环境.</p><p>就我个人而言,主要使用tabular,array这两种表格环境.</p><p>先来介绍<strong>tabular</strong></p><p>tabular的命令结构如下:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">\begin&#123;tabular&#125;[位置]&#123;列格式&#125;<br>内容&amp; 内容&amp;&#x2F;&#x2F; %其中&amp; 表示分隔 ,&#x2F;&#x2F;表示换行<br>\end&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>其中’位置’为可选参数,</p><p>‘列格式’可以设置表格中数据的对齐方式,列宽,列间距等</p><ul><li>l 左对齐</li><li>c 居中对齐</li><li>r 右对齐</li><li>| 画一条垂直线</li><li>|| 画两条垂直线</li><li>{n}{列格式} 用n次列格式 ,举例: *{3}{|c}相当于输入 |c|c|c</li><li>@{声明} 它会将侧边与列之间的空白或是列与列之间的空白删除插入声明的内容</li></ul><p><strong>合并单元格</strong></p><p>\cline{i-j}可以从第i列的左侧到第j列的右侧画一条线.</p><p>\hline 画一条与列表宽度相同的水平线</p><p>如果要合并行需要使用multirow 宏包,</p><p>\multirow{n}*{内容} 表示合并n行以’内容’填充其中.</p><p>\multicolumn{n}{列格式}{内容}表示合并n列,以’内容’填充,列格式与前面介绍的相同.下面举个例子来说明.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;multirow&#125;<br>\begin&#123;document&#125;<br>\begin&#123;tabular&#125;&#123;||c|c|c|c||&#125;<br>\hline<br>\multirow&#123;2&#125;*&#123;合并行&#125;&amp;\multicolumn&#123;3&#125;&#123;c||&#125;&#123;合并列&#125;\\<br>\cline&#123;2-4&#125;<br>&amp;测试&amp;测试&amp;测试\\<br>\hline<br>\end&#123;tabular&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-b1e312ddae0b39778eee21af6ef80a31_720w.jpg" alt="img"></p><p><strong>array</strong></p><p>array需要使用宏包array</p><p>array的命令结构如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;array&#125;[位置]&#123;列格式&#125;<br>内容&amp; 内容&amp;// %其中&amp; 表示分隔 ,//表示换行<br>\end&#123;array&#125;<br></code></pre></td></tr></table></figure><p>可以看到与tabular完全相同,array就是在数学模式中的表格环境.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;array&#125;<br>\begin&#123;document&#125;<br>\begin&#123;equation&#125;<br>\left\&#123;<br>\begin&#123;array&#125;&#123;*&#123;3&#125;&#123;l@&#123;+&#125;&#125;l@&#123;=&#125;l&#125;<br>a_&#123;11&#125;x_&#123;1&#125;&amp;a_&#123;12&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;1n&#125;x_n&amp;c_1\\<br>a_&#123;21&#125;x_&#123;1&#125;&amp;a_&#123;22&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;2n&#125;x_n&amp;c_2\\<br>a_&#123;i1&#125;x_&#123;1&#125;&amp;a_&#123;i2&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;in&#125;x_n&amp;c_i\\<br>a_&#123;m1&#125;x_&#123;1&#125;&amp;a_&#123;m2&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;mn&#125;x_n&amp;c_m\\ <br>\end&#123;array&#125;\right.<br>\end&#123;equation&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-ebac80d794b8c4c05496e75ccea1cdfc_720w.jpg" alt="img"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表环境有itemize,enumerate和description</p><p>itemize相当于无序列表,enumerate相当于有序列表</p><p>itemize的命令结构如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;itemize&#125;<br>\item[标志] 条目<br>\end&#123;item&#125;<br></code></pre></td></tr></table></figure><p>标志默认是实心大圆点,可以更改为其他标志,示例如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;itemize&#125;<br>\item 第一条测试<br>\item[$\rightarrow$] 第二条测试<br>\end&#123;itemize&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-a276dfdc63a147ce4a75f5cb4b90bba6_720w.jpg" alt="img"></p><p>排序列表enumerate前面的标号默认是1,2,3….,不再赘述</p><h2 id="图形插入"><a href="#图形插入" class="headerlink" title="图形插入"></a>图形插入</h2><p>插图需使用graphics宏包</p><p>常用的插图命令为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\includegraphics[参数1=选项,...]&#123;图名&#125;<br></code></pre></td></tr></table></figure><p>下面介绍一下常用的参数</p><ul><li>height 插图的高度</li><li>width 插图的宽度</li><li>scale 相比于原图缩放系数</li><li>angle 正值表示逆时针旋转,负值表示顺时针旋转</li></ul><p>当把图插入段落中时需使用figure环境,示例如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;figure&#125;[htbp]%<br>\centering<br>\includegraphics [scale=0.6]&#123;test.jpg&#125;<br>\caption&#123;测试&#125;%标题<br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><blockquote><p>『h』当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩的页面不够，这一参数将不起作用。<br>『t』顶部。将图形放置在页面的顶部。<br>『b』底部。将图形放置在页面的底部。<br>『p』浮动页。将图形放置在一只允许有浮动对象的页面上。</p></blockquote><p>当我们需要两个或多个图并排排列时,需使用minipage环境,示例如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;figure&#125;[htbp]<br>\centering<br>\begin&#123;minipage&#125;[c]&#123;0.5\textwidth&#125;<br>\centering<br>\includegraphics[width=0.3\textwidth]&#123;test.jpg&#125;<br>\caption&#123;测试1&#125;<br>\end&#123;minipage&#125;%<br>\begin&#123;minipage&#125;[c]&#123;0.5\textwidth&#125;<br>\centering<br>\includegraphics[width=0.3\textwidth]&#123;test.jpg&#125;<br>\caption&#123;测试2&#125;<br>\end&#123;minipage&#125;<br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>参考文献可以使用环境thebibliography,</p><p>thebibliography的命令结构如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;thebibliography&#125;&#123;最宽序号&#125;<br>\bibitem[文献序号1]&#123;检索名1&#125; 文献信息1<br>\end&#123;thebibliography&#125;<br></code></pre></td></tr></table></figure><p>通常用99为最宽序号</p><p>文献序号用于设置文献在参考文献中的序号,可以不填,默认为按顺序的阿拉伯数字</p><p>检索名用于正文中的引用</p><p><strong>引用命令</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\cite&#123;检索名1,检索名2...&#125;<br></code></pre></td></tr></table></figure><p>在参考文献较少时可以使用thebibliography环境,为了更好的管理文献可以使用BibTeX,文献管理程序.</p>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用命令(1)</title>
    <link href="/2020/12/23/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(1)/"/>
    <url>/2020/12/23/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(1)/</url>
    
    <content type="html"><![CDATA[<p>这一篇主要记录自己常用的一些LaTeX的操作,包括常用的一些格式,下一节LaTeX文章主要为数学公式及图表的内容.</p><h2 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h2><p>一般来说,我们写TeX文档时,第一句命令就是文档类型的命令.</p><p>文档类型主要有 article,report,book,beamer,还有用于中文排版的ctexart,ctexrep,ctexbook分别对应article,report,book.用于排版中文的文类可以不用再调用ctex宏包直接使用中文.而且文档中的图,表,日期等都是中文显示.一般写一些课程小论文用ctexart就可以.</p><h2 id="标题页"><a href="#标题页" class="headerlink" title="标题页"></a>标题页</h2><p>LaTeX中提供了一组题名的命令,可以用于生成标题页的题名,作者,日期等内容.</p><p>以下命令写在导言区中.</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">\title&#123;论文&#125;%论文题名<br>\author&#123;作者&#125;%作者姓名<br>%\<span class="hljs-keyword">date</span>&#123;&#125;%日期<br></code></pre></td></tr></table></figure><p>如果不设置日期,将默认是今天的日期.</p><p>在正文中</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\maketitle</span><br></code></pre></td></tr></table></figure><p>将会自动生成默认格式的标题页</p><p><img src="https://pic4.zhimg.com/v2-c1cd03a4f65d8a0900d7c82d5a61f613_b.jpg" alt="img"></p><p>一般写一些课内小论文之类的直接用默认格式,如果要写论文或是毕业论文之类比较正式的文档就可以使用模板.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\<span class="hljs-selector-tag">thanks</span>&#123;&#125;%添加脚注,对题名的说明或是作者简介之类.<br></code></pre></td></tr></table></figure><p>article默认题名与正文相连,不单独设页,book,report则会创建单独的一页.</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一般在正文前都有摘要,在文档类article,ctexart中都提供了摘要环境</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">\<span class="hljs-keyword">begin</span>&#123;<span class="hljs-keyword">abstract</span>&#125;<br>内容<br>\<span class="hljs-keyword">end</span>&#123;<span class="hljs-keyword">abstract</span>&#125;<br></code></pre></td></tr></table></figure><p>该环境会默认生成粗体字居中的摘要标题.</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>在正文之前使用命令</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\tableofcontents</span><br></code></pre></td></tr></table></figure><p>就可以生成默认格式的目录,如果对默认的目录格式不满意可以使用titletoc宏包修改目录的格式.</p><p>目录格式命令</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">\titlecontents</span><span class="hljs-template-variable">&#123;标题名&#125;</span><span class="xml">[左间距]</span><span class="hljs-template-variable">&#123;标题格式&#125;</span><span class="hljs-template-variable">&#123;标题标志&#125;</span><span class="hljs-template-variable">&#123;无序号标题&#125;</span><span class="hljs-template-variable">&#123;指引线与页码&#125;</span><span class="xml">[下间距]</span><br></code></pre></td></tr></table></figure><p>下面是我使用的目录页设置命令</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\t</span>itlecontents&#123;section&#125;[0em]&#123;<span class="hljs-symbol">\z</span>ihao&#123;4&#125;<span class="hljs-symbol">\b</span>f &#125;&#123;<span class="hljs-symbol">\t</span>hecontentslabel<span class="hljs-symbol">\ </span>&#125;&#123;&#125;<br>&#123;<span class="hljs-symbol">\h</span>space&#123;.5em&#125;<span class="hljs-symbol">\t</span>itlerule*[4pt]&#123;$<span class="hljs-symbol">\c</span>dot$&#125;<span class="hljs-symbol">\c</span>ontentspage&#125;<br><span class="hljs-symbol">\t</span>itlecontents&#123;subsection&#125;[2em]&#123;<span class="hljs-symbol">\v</span>space&#123;0.1<span class="hljs-symbol">\b</span>aselineskip&#125;<span class="hljs-symbol">\z</span>ihao&#123;-4&#125;&#125;&#123;<span class="hljs-symbol">\t</span>hecontentslabel<span class="hljs-symbol">\ </span>&#125;&#123;&#125;<br>&#123;<span class="hljs-symbol">\h</span>space&#123;.5em&#125;<span class="hljs-symbol">\t</span>itlerule*[4pt]&#123;$<span class="hljs-symbol">\c</span>dot$&#125;<span class="hljs-symbol">\c</span>ontentspage&#125;<br><span class="hljs-symbol">\t</span>itlecontents&#123;subsubsection&#125;[4em]&#123;<span class="hljs-symbol">\v</span>space&#123;0.1<span class="hljs-symbol">\b</span>aselineskip&#125;<span class="hljs-symbol">\z</span>ihao&#123;-4&#125;&#125;&#123;<span class="hljs-symbol">\t</span>hecontentslabel<span class="hljs-symbol">\ </span>&#125;&#123;&#125;<br>&#123;<span class="hljs-symbol">\h</span>space&#123;.5em&#125;<span class="hljs-symbol">\t</span>itlerule*[4pt]&#123;$<span class="hljs-symbol">\c</span>dot$&#125;<span class="hljs-symbol">\c</span>ontentspage&#125;<br></code></pre></td></tr></table></figure><h2 id="页眉页脚"><a href="#页眉页脚" class="headerlink" title="页眉页脚"></a>页眉页脚</h2><p>LaTeX中有4种页眉页脚的版式</p><ol><li>empty 页眉页脚都空置</li><li>plain 页眉空置,页脚中间是页码,无页脚线</li><li>headings 偶数页页眉左端是页码,右端是章标题;奇数页页眉的右端是页码,左端是节标题,是book类的默认格式</li><li>myheadings 格式与headings基本相同,左页页眉的右端和右页页眉的左端空置</li></ol><p>使用命令\pagestyle{}设置版式,使用\thispagestyle{}设置当前页的格式,页码一般从正文开始,所以正文前的页一般要设置为empty版式,</p><p>如果需要自己设置页码页眉的格式可以用fancyhdr宏包.</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">\<span class="hljs-variable">fancyhead</span><span class="hljs-punctuation">[</span>参数<span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#123;</span>页眉内容<span class="hljs-punctuation">&#125;</span><br>\<span class="hljs-variable">fancyfoot</span><span class="hljs-punctuation">[</span>参数<span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#123;</span>页眉内容<span class="hljs-punctuation">&#125;</span><br><span class="hljs-operator">%</span>参数选项可以为<span class="hljs-variable">EL</span><span class="hljs-operator">,</span><span class="hljs-variable">EC</span><span class="hljs-operator">,</span><span class="hljs-variable">ER</span><span class="hljs-operator">,</span><span class="hljs-variable">OL</span><span class="hljs-operator">,</span><span class="hljs-variable">OC</span><span class="hljs-operator">,</span><span class="hljs-variable">OR</span>其中<span class="hljs-built_in">E</span>代表左页<span class="hljs-operator">,</span><span class="hljs-built_in">O</span>代表右页<span class="hljs-operator">,</span><span class="hljs-variable">L</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">R</span>分别代表左<span class="hljs-operator">,</span>中<span class="hljs-operator">,</span>右<br></code></pre></td></tr></table></figure><p>目录页的设置可以参考<a href="http://www.ctex.org/PackageCTeX/">这里</a></p><h2 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h2><p>需使用listings宏包,使用lstset在导言区配置,</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">\lstset&#123;<br><span class="hljs-attribute">numbers</span>=left,  <br><span class="hljs-attribute">frame</span>=tb,<br><span class="hljs-attribute">aboveskip</span>=3mm,<br><span class="hljs-attribute">belowskip</span>=3mm,<br><span class="hljs-attribute">showstringspaces</span>=<span class="hljs-literal">false</span>,<br><span class="hljs-attribute">columns</span>=flexible,<br><span class="hljs-attribute">framerule</span>=1pt,<br><span class="hljs-attribute">rulecolor</span>=\color&#123;gray!35&#125;,<br><span class="hljs-attribute">backgroundcolor</span>=\color&#123;gray!5&#125;,<br>basicstyle=&#123;\ttfamily&#125;,<br><span class="hljs-attribute">numberstyle</span>=\tiny\color&#123;gray&#125;,<br><span class="hljs-attribute">keywordstyle</span>=\color&#123;blue&#125;,<br><span class="hljs-attribute">commentstyle</span>=\color&#123;dkgreen&#125;,<br><span class="hljs-attribute">stringstyle</span>=\color&#123;mauve&#125;,<br><span class="hljs-attribute">breaklines</span>=<span class="hljs-literal">true</span>,<br><span class="hljs-attribute">breakatwhitespace</span>=<span class="hljs-literal">true</span>,<br><span class="hljs-attribute">tabsize</span>=3,<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是我的代码环境设置,可以参考.</p><p>在需要插入代码的时候</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">\<span class="hljs-built_in">begin</span>&#123;lstlisting&#125;[language=C++,escapeinside=``]<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> main<br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Hello world!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//`输出`</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>\<span class="hljs-built_in">end</span>&#123;lstlisting&#125;<br></code></pre></td></tr></table></figure><p>其中如果需要使用中文需要逃逸环境.</p><p>显示效果如下:</p><p><img src="https://pic3.zhimg.com/v2-32d7e95010dac6872d14c370040b9e62_b.jpg" alt="img"></p><h2 id="其他一些想到的"><a href="#其他一些想到的" class="headerlink" title="其他一些想到的"></a>其他一些想到的</h2><p>geometry宏包可以改变页边距</p><p>使用如下:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">\usepackage[a4paper,<span class="hljs-keyword">left</span>=<span class="hljs-keyword">cm</span>,<span class="hljs-keyword">right</span>=<span class="hljs-keyword">cm</span>,top=<span class="hljs-keyword">cm</span>,bottom=<span class="hljs-keyword">cm</span>]&#123;geometry&#125;<br></code></pre></td></tr></table></figure><p>脚注:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">\footnote</span><span class="hljs-template-variable">&#123;文字&#125;</span><br></code></pre></td></tr></table></figure><p>间距调整</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">\<span class="hljs-attr">vspace&#123;1</span>cm&#125;<span class="hljs-meta">%</span>水平间距调整<br>\<span class="hljs-attr">vskip 7</span>cm <span class="hljs-meta">%</span>垂直间距调整<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>packed memory arrays-rewired</title>
    <link href="/2020/12/14/packed%20memory%20arrays-rewired/"/>
    <url>/2020/12/14/packed%20memory%20arrays-rewired/</url>
    
    <content type="html"><![CDATA[<h1 id="packed-memory-arrays-rewired"><a href="#packed-memory-arrays-rewired" class="headerlink" title="packed memory arrays-rewired"></a>packed memory arrays-rewired</h1><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="a-b-tree"><a href="#a-b-tree" class="headerlink" title="(a,b)-tree"></a>(a,b)-tree</h2><p>(a,b)-tree是一个平衡的(所有的叶子在同一层)搜索树，</p><ul><li>2≤a≤(b+1)/2,当a==(b+1)/2时 为b-tree</li><li>根结点最多有b个子结点。</li><li>除了根节点之外，每个内部节点至少有a个子节点，最多有b个子节点。</li><li>所有从根到叶的路径都是相同的长度。</li></ul><p>(2,3)-tree 是b树 (a,b)-tree相当于b-tree的扩展,b-tree是(a,b)的特例. </p><p><a href="https://cs.lmu.edu/~ray/notes/abtrees/">https://cs.lmu.edu/~ray/notes/abtrees/</a></p><p><a href="https://en.wikipedia.org/wiki/(a,b)-tree">https://en.wikipedia.org/wiki/(a,b)-tree</a></p><h2 id="传统-PMAa"><a href="#传统-PMAa" class="headerlink" title="传统 PMAa"></a>传统 PMAa</h2><p>一个数组，其中的元素是按照排序的顺序存储的，交叉元素或间隙。间隙的目的是提供额外的空间，以便在数组的任意位置插入新元素，而不需要移动现有元素的长序列来维持排序顺序。</p><h3 id="PMA的实现"><a href="#PMA的实现" class="headerlink" title="PMA的实现"></a>PMA的实现</h3><p>搜索数组中的元素可以通过二分搜索利用排序顺序来实现。范围扫描包括在范围的两个端点之间对数组进行顺序迭代。这里，空槽被简单地忽略。要插入新元素，算法首先在数组中搜索它的目标槽。但是，如果该位置已经被另一个元素e占据，则算法首先将e和e的所有相邻元素移向数组中最接近的间隙。最后，要删除数组中的元素，算法只需将其槽标记为空。</p><p>在部分数据变得过于稀疏或过于密集时，在本地重新调整数据结构。</p><ol><li>定位要插入元素的位置。我们要么事先知道这个，要么执行代价为O(log2N)的二分查找。</li><li>如果我们要插入的单元格是空闲的，我们只需添加元素，并将该单元格标记为used。</li><li>但是，如果要插入的单元格被使用了，我们计算所需单元格所在的最小块(大小为log N)的上限密度阈值，并检查是否会违反上限密度阈值。如果我们注意到没有超过阈值，我们只需重新平衡所有元素，包括新的元素到那个块中。如果我们违反了较高的密度阈值，我们考虑一个两倍大的块(其中包括我们将插入的单元格)，并检查是否违反了密度阈值。我们不断向上移动，直到找到一个不违反上密度阈值的块。</li><li>如果我们找不到这样的块，我们就分配一个两倍大的数组，并整齐地将所有现有的元素复制到新的数组中，元素之间的间隔是恒定的.</li></ol><h3 id="APMA"><a href="#APMA" class="headerlink" title="APMA"></a>APMA</h3><p>hammering 敲打指的是连续且频繁的插入发生在数组的相同区域。</p><p>在hammering发生的段放置更多的gap,但也可能会出现乒乓效应,性能甚至不如传统PMA.</p><p><img src="https://i.loli.net/2020/10/31/3lUX82qmFJyBtip.png" alt="image-20201031194615762"></p><p>如图所示,最后插入的是14,15,16.apma认为在第一段中插入数据过多,于是在rebalance的过程中在第一段中放置更多的gap,但是实际上的插入序列如果是17,18,19,则性能可能会很差.</p><h3 id="Calibrator-tree"><a href="#Calibrator-tree" class="headerlink" title="Calibrator tree"></a>Calibrator tree</h3><p><img src="https://i.loli.net/2020/11/08/rug3HlaGUioPILm.png" alt="image-20201108164808490"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>基于树的索引结构的物理内存布局会随着时间的推移而恶化(比如B-树中的合并与分裂),物理级别上的顺序扫描就会变成非顺序的，因此扫描操作会变慢.Packed Memory Arrays(PMA)通过管理所有数据在一个顺序稀疏阵列来防止顺序扫描变成非顺序的。本文在PMA的基础上提出了一个改进的数据结构:Rewired Memory Array(RMA)。RMA可以达到具有竞争力的更新和点查找性能，同时始终提供优越的扫描性能-接近密集列扫描。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>针对列存存储引擎,本文提出了一种基于PMA的数据结构。列存变得稀疏而不是密集。在存储的元素中有空的间隙，以适应未来可能的更新。因此，可以直接就地执行更新。扫描是顺序的，比(a,b)-tree快. 更新可以在对数复杂度完成，但比不上(a,b)-tree。</p><p><img src="https://i.loli.net/2020/11/08/8FaG4lIwVOip7PD.png" alt="image-20201108124846773"></p><p>有几个因素会阻碍稀疏数组的性能。对于扫描，通过检查数组的每个插槽是否被填满，需要付出大量的CPU 代价。对于更新，数据结构偶尔需要重新平衡，这增加了这些操作的平均成本。此外，在重新平衡期间，数组中的元素可能会被移动，这也会导致PMAs的索引分隔符键的更新.(索引存储每个段的最小key).在存在数据倾斜的情况下，稀疏数组会遇到最坏的情况，并且在更新期间会进行更多的内部重组.</p><h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ul><li>通过提出cluster、固定大小的段、静态索引和内存重布线，克服了scan的一些性能问题，同时减少了内部重平衡的延迟。</li><li>对自适应再平衡进行了改进。自适应再平衡减少了出现更新倾斜时发生的再平衡数量。尽管如此，我们还是发现了APMA的自适应再平衡策略是有害的，并提出了一种新的算法，解决了它的局限性。</li><li>提出了一种新的批量装载算法。它特别适合流场景，其中数组的基数保持不变，并且定期分批执行具有相同插入和删除数量的更新。</li></ul><h2 id="RMA"><a href="#RMA" class="headerlink" title="RMA"></a>RMA</h2><p>RMA的目的是提供快速的面向列的扫描，同时在更新方面接近(a, b)树。</p><h3 id="segments"><a href="#segments" class="headerlink" title="segments"></a>segments</h3><p>段的大小是固定的，不依赖于数据结构的当前基数或容量,将段大小绑定到I/O模型的块大小O(B)，</p><p>cluster:将长序列的元素放在一起,将长序列的间隔放在一起.</p><p>在每个槽，扫描需要检查它是否为空。为了避免检查槽是否为空，我们在一个名为cards的数组中跟踪每个段的当前基数。我们把所有的元素放在片段的一端，把间隙放到另一端。奇数段将元素放在右边,偶数段将元素放在左边.</p><p>扫描对每两个片段的密集值序列执行一个紧循环。(在两个段内进行二分?)</p><p>RMAs非常像(a, b)树。实际上，组成数组的段类似于(a, b)树的叶节点。</p><p>(a, b)树在更新中有优势，而稀疏数组在扫描中有优势。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>RMAs维护一个静态索引以改进点查找和更新。它是静态的，在RMA调整大小后构建，它包含固定数量的条目。尽管如此，单个条目还是可以改变的，在再平衡期间就会发生。索引只有分隔符键被存储，打包在一个连续的数组中。节点遍历是通过计算节点与数组中当前位置的偏移来执行的</p><p><img src="https://i.loli.net/2020/11/08/mv9RHA1MGEOdJD3.png" alt="image-20201108135554072"></p><p>根节点包含r分隔符键，和r + 1个孩子,最左边的r个子树是高度为h - 1的满子树.槽的内容是相关段的分隔键.</p><h3 id="re-balancing"><a href="#re-balancing" class="headerlink" title="re-balancing"></a>re-balancing</h3><p>rebalance包含两个过程,第一个过程中,将元素移动和压缩到间隔的右端或辅助附加存储中。在第二个过程中，继续前进，将元素复制到它们在数组中的最终位置。如果重新平衡的间隔小于虚拟页，我们的解决方案仍然遵循这种方案。否则，我们直接将元素从数组的页面移动并直接展开，以将parray重新平衡为一组未使用的物理页面pbuffer。最后，我们在parray和pbuffer之间一个一个地交换虚拟地址。这种技术的优点是它只对每个元素执行一次复制，而不是两次。</p><p><img src="https://i.loli.net/2020/11/08/X8KJVozAfnjyevb.png" alt="image-20201108143530259"></p><p>除了RMA使用的空间之外，我们还维护了一组按需分配的备用缓冲区。在重新平衡时，元素被重新分配到缓冲区空间中(参见图6b)。然后，使用内存重新连接，来自缓冲区的页面成为阵列的一部分，而阵列的旧物理页面成为备用缓冲区，以便在未来重新平衡时重用(参见图6c)。</p><p>在RMA当前使用的存储之后是备用缓冲区的物理页面(如图6a所示)。当需要扩展RMA时，我们吸收RMA中现有的备用缓冲区。如果需要缩小RMA，我们将RMA结束时释放的页面吸收到缓冲区中。好处是减轻从操作系统获取新的物理页面的开销.</p><h3 id="bulk-loading"><a href="#bulk-loading" class="headerlink" title="bulk loading"></a>bulk loading</h3><p>避免在单个批处理中对相同的段进行多次再平衡。</p><p>自顶向下的策略:假设批处理中的元素已经预先排序，关键思想是从根开始遍历校准器树，然后递归地将输入序列传播给子元素。但是，如果给定节点的阈值不能满足，算法将触发再平衡，将输入序列与当前窗口中的现有元素合并。缺点是可能会造成额外的rebalance,因为顶部的阈值比较小.</p><p>自底向上的策略:首先，对插入的输入序列S进行排序。然后，该算法分三次运行。在第一次遍历中，它扫描S，只改变将插入元素的每个段的最终基数。在第二步中，它扫描被插入的片段，检查阈值是否被遵守。如果没有，它确定需要重新平衡的段间隔。最后，它对被插入的片段进行第三步。如果一个段没有标记进行再平衡，它就简单地插入来自S的相关元素,否则,rebalance第二步中的段间隔,合并相关的现有元素与排序后的序列S. 该方法可以扩展到批量插入和删除。</p><h3 id="kv分离"><a href="#kv分离" class="headerlink" title="kv分离"></a>kv分离</h3><p>改进了点查找，因为查找特定键需要遍历的内存空间更少了。</p><h3 id="自适应-re-balancing"><a href="#自适应-re-balancing" class="headerlink" title="自适应 re-balancing"></a>自适应 re-balancing</h3><p>采用自适应再平衡来减少锤击带来的未来再平衡的数量。自适应策略被分为两个不同的部分。在第一部分中，在每次插入时，会在一个名为Detector的自定义数据结构中收集一些额外的元数据。第二部分是实际的再平衡机制，其中检查收集的元数据，以确定数组中元素的重新分布。其核心算法是递归的自适应算法。它从当前calibrator子树的顶部开始，在每一步中，它将确定分配到其子节点上的元素的数量。</p><p><img src="https://i.loli.net/2020/10/31/bPMGxNy9Unr4pDz.png" alt="image-20201031200041751"></p><p><img src="https://i.loli.net/2020/10/31/9KoMQU6nFLWP3iC.png" alt="image-20201031200641386"></p><h3 id="detector"><a href="#detector" class="headerlink" title="detector"></a>detector</h3><p>算法1是用于更新片段s元数据的代码，在每次插入数据之后调用。它首先在Q中记录当前操作的时间戳。时间戳可以通过某个离散的全局计数器或CPU时间戳计数器获得。此外，它还检查正在插入的键k的后继或前驱是否分别匹配kbwd或kfwd。如果两个键中有一个匹配，相关的计数器增加1，直到最大阈值SC。否则，两个计数器都减少1。当计数器达到0时，相关的kbwd和kfwd值被succk和predk替换</p><p>与kbwd关联的值3意味着，在最近的插入中，刚刚插入的键的后继至少有3次是19。因此，算法可能会猜测，未来新的插入很可能在这个范围内[predecessor(19)， 19]。</p><p><img src="https://i.loli.net/2020/11/08/rsqHA8uc6JOZFdL.png" alt="image-20201108151101780"></p><h3 id="自适应算法"><a href="#自适应算法" class="headerlink" title="自适应算法"></a>自适应算法</h3><p>自适应算法对传统的TPMA再平衡过程进行了整合和扩充。与TPMA一样，整个过程的第一步是找到重新平衡的窗口。该操作通过遍历和验证校准树的密度阈值来完成。第二步，称为预处理阶段，包括产生一组有标记的间隔，利用检测器中的信息。如果没有创建标记间隔，则按照TPMA中的方法进行再平衡过程.否则，第三步是实际的自适应算法。该算法自顶向下遍历calibrator树，确定要放置在每个子节点上的元素数量，传输基数最小的节点中标记的间隔。这一步的输出是W中所有段的目标基数。在自适应算法的执行过程中，数组中的任何元素都不会被物理复制。只有在其结束时，当W中所有段的目标基数已经确定时，元素才会在数组中重新分布。</p><p>标记一些最近有更新的段。如果其段关联的计数器大于给定的阈值，则会发出带有kbwd或kfwd的大小为2的间隔.</p><p>自适应算法是自顶向下遍历校准器子树，根在W.</p><p>objective function 尝试将相同数量的标记间隔重新分配给每个子节点。如果不能做到这一点，例如 只有一个间隔 其余标记的间隔被移动到基数最小的子节点</p><p><img src="https://i.loli.net/2020/11/08/JHCdTKugaA9m7oN.png" alt="image-20201108193201610"></p><p>在继续进行下一个递归级别之前，可能需要增加或者减少节点的目标基数。如果一个孩子v的元素密度小于其较低的阈值，那么它就会尽可能多地从其兄弟姐妹那里借用元素，从而使元素密度大于给定阈值.</p><p><img src="https://i.loli.net/2020/11/02/Gz8yB57mYSNxIJA.png" alt="image-20201102205433999"></p>]]></content>
    
    
    
    <tags>
      
      <tag>paper reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/12/hello-world/"/>
    <url>/2020/12/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
