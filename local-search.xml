<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ClickHouse解析</title>
    <link href="/2021/01/26/clickhouse_principle/"/>
    <url>/2021/01/26/clickhouse_principle/</url>
    
    <content type="html"><![CDATA[<h1 id="clickhouse简介"><a href="#clickhouse简介" class="headerlink" title="clickhouse简介"></a>clickhouse简介</h1><p>“When we released ClickHouse, we had only one goal in mind, to give people <strong>the fastest analytical DBMS</strong> in the world.”                                                                 — Alexey Milovidov</p><h2 id="ClickHouse提出背景"><a href="#ClickHouse提出背景" class="headerlink" title="ClickHouse提出背景"></a>ClickHouse提出背景</h2><p>初始设计目标是服务于Yandex.Metrica.这是一款web流量分析工具.在采集数据时,一次页面点击(click),就会产生一条记录,clickhouse就是基于这样的点击事件流(Click Stream)的数据仓库(Data WareHouse).</p><p><img src="https://i.loli.net/2020/10/25/uLgO3bylXiJBS1D.png" alt="image-20201025125556599"></p><h2 id="clickhouse适用场景"><a href="#clickhouse适用场景" class="headerlink" title="clickhouse适用场景"></a>clickhouse适用场景</h2><p>各类数据分析类场景(BI领域等)</p><h2 id="clickhouse不适用的场景"><a href="#clickhouse不适用的场景" class="headerlink" title="clickhouse不适用的场景"></a>clickhouse不适用的场景</h2><ul><li>不支持事务<ul><li>已经有计划去实现在单个事务中支持大规模数据的insert.</li><li>完整的ANSI SQL Transaction不在roadmap中.</li></ul></li><li>不擅长根据主键按行粒度进行查询（虽然支持），故不应该把ClickHouse当作Key-Value数据库使用.</li><li>不擅长按行update delete(虽然支持).</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>DDL,DML,权限控制,数据备份与恢复,分布式</li><li>列式存储与数据压缩(降低IO 向量化执行SIMD)</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://i.loli.net/2020/10/25/BoWdPmkbcTEeVIC.png" alt="image-20201025131707509"></p><ul><li>server  在接入层 ClickHouse 支持多种接口：<ul><li>Reust HTTP 方式.</li><li>ClickHouse Native，通过 ClickHouse 协议 TCP 的方式接入，性能会更好。</li><li>其他 mysql等.</li></ul></li><li>parser 解析器,解析器创建AST.</li><li>Interpreter 解释器,从AST创建查询执行流水线.<ul><li>IBlockInputStream接口总共有60多个实现类，它们涵盖了ClickHouse数据摄取的方方面面。这些实现类大致可以分为三类：第一类用于处理数据定义的DDL操作，例如DDLQueryStatusInputStream等；第二类用于处理关系运算的相关操作，例如LimitBlockInput-Stream、JoinBlockInputStream及AggregatingBlockInputStream等；第三类则是与表引擎呼应，每一种表引擎都拥有与之对应的BlockInputStream实现，例如MergeTreeBaseSelect-BlockInputStream（MergeTree表引擎）.  类似于算子.以 insert为例.</li></ul></li><li>Storages</li><li>datatype 数据的序列化和反序列化.</li></ul><h1 id="mergetree"><a href="#mergetree" class="headerlink" title="mergetree"></a>mergetree</h1><p>表引擎是clickhouse设计中的特色.clickhouse存储层有多种表引擎.最常用最基本的是mergetree.</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>column   field</strong></p><p>内存中的一列数据由一个column对象表示.如果需要操作单个具体的数值则需要使用field对象,表示一个单值.</p><ul><li><p>field类似union,可以存储不同类型的值,但在任何时候只有一个值可以被存储.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// src/Core/Field.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br><span class="hljs-built_in">std</span>::<span class="hljs-keyword">aligned_union_t</span>&lt;DBMS_MIN_FIELD_SIZE - <span class="hljs-keyword">sizeof</span>(Types::Which),<br>        Null, UInt64, UInt128, Int64, Int128, Float64, String, Array, Tuple, Map,<br>        DecimalField&lt;Decimal32&gt;, DecimalField&lt;Decimal64&gt;, DecimalField&lt;Decimal128&gt;, DecimalField&lt;Decimal256&gt;,<br>        AggregateFunctionStateData,<br>        UInt256, Int256<br>        &gt; storage;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li>根据数据类型不同,column有不同的实现对象.以<code>ColumnInt8</code>为例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> ColumnInt8 = ColumnVector&lt;Int8&gt;;<br>...<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColumnVector</span> <span class="hljs-keyword">final</span> :</span> <span class="hljs-keyword">public</span> COWHelper&lt;ColumnVectorHelper, ColumnVector&lt;T&gt;&gt;<br>&#123;<br>    ...<br>    <span class="hljs-keyword">using</span> ValueType = T;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> is_POD = !is_big_int_v&lt;T&gt;;<br>    <span class="hljs-keyword">using</span> Container = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;is_POD,<br>                                         PaddedPODArray&lt;ValueType&gt;,<br>                                         <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ValueType&gt;&gt;;<br>    ...<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>block</strong> </p><p>clickhouse的内部数据操作是面向block对象的.本质是由数据对象,datatype 与列名称组成的三元组(column datatype 列名称字符串).Column提供了数据的读取能力，而DataType知道如何正反序列化，在具体的实现过程中，Block并没有直接聚合Column和DataType对象，而是通过ColumnWithTypeAndName对象进行间接引用。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// src/Core/Block.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ColumnWithTypeAndName</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>    ColumnPtr column;<br>    DataTypePtr type;<br>    String name;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">using</span> ColumnsWithTypeAndName = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ColumnWithTypeAndName&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block</span></span><br><span class="hljs-class">&#123;</span>...<br> <span class="hljs-keyword">using</span> Container = ColumnsWithTypeAndName;   <br> ...<br>     <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mergetree的创建"><a href="#mergetree的创建" class="headerlink" title="mergetree的创建"></a>mergetree的创建</h2><p>engine=MergeTree();</p><ul><li>partition by 分区键 </li><li>order by 排序键</li><li>primary key 主键</li></ul><p><img src="https://i.loli.net/2020/10/27/PLtsQ9b1NlDndJA.png" alt="image-20201027125337217"></p><ul><li><p>partition 分区目录 属于相同分区的数据最终会被合并到同一个分区目录,而不同分区的数据不会被合并在一起.</p></li><li><p>checksums 校验文件 存储了各类文件的size和size的哈希值 用于校验文件的完整性和正确性</p></li><li><p>columns 列信息 明文存储<img src="https://i.loli.net/2020/10/27/QGSK4Pw5UYB7V1D.png" alt="image-20201027125623314"></p></li><li><p>计数文件 记录当前数据分区目录下的数据总行数</p></li><li><p>primary.idx 一级索引文件 存放稀疏索引</p></li><li><p>[column].bin 数据文件</p></li><li><p>[column].mrk 列字段标记文件 保存了bin文件中的数据偏移量.首先通过稀疏索引（primary.idx）找到对应数据的偏移量信息（.mrk），再通过偏移量直接从．bin文件中读取数据</p></li><li><p>mrk2 如果采用了自适应大小的索引间隔 标记文件为mrk2</p></li><li><p>partition.dat minmax_[column].idx 如果使用了分区键 则会生成 例如EventTime字段对应的原始数据为2019-05-01、2019-05-05，分区表达式为PARTITION BY toYYYYMM(EventTime)。partition.dat中保存的值将会是2019-05，而minmax索引中保存的值将会是2019-05-012019-05-05。</p></li><li><p>skp_idx 二级索引</p></li></ul><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>在ClickHouse中，数据分区(partition)是针对本地数据而言的</p><p>分区规则:</p><ul><li>不指定分区键 默认所有数据会被写入all分区</li><li>分区键为整型 直接按照整型的字符形式输出 作为分区id的取值</li><li>日期类型 按照yyyymmdd进行格式化后的字符形式输出</li><li>其他类型 hash之后的值作为分区id的取值</li></ul><p><img src="https://i.loli.net/2020/10/27/vqruVRd9wFLnCsT.png" alt="image-20201027131306288"></p><p>数据在写入时，会对照分区ID落入相应的数据分区</p><h3 id="分区目录命名"><a href="#分区目录命名" class="headerlink" title="分区目录命名"></a>分区目录命名</h3><p><img src="https://i.loli.net/2020/10/27/zbSaBYPRlDeqsN1.png" alt="image-20201027131505524"></p><h3 id="分区目录合并"><a href="#分区目录合并" class="headerlink" title="分区目录合并"></a>分区目录合并</h3><p>MergeTree的分区目录并不是在数据表被创建之后就存在的，而是在数据写入过程中被创建的。伴随着每一批数据的写入（一次INSERT语句）, MergeTree都会生成一批新的分区目录。即便不同批次写入的数据属于相同分区，也会生成不同的分区目录。也就是说，对于同一个分区而言，也会存在多个分区目录的情况。</p><p>合并规则:</p><ul><li>MinBlockNum：取同一分区内所有目录中最小的MinBlockNum值。</li><li>MaxBlockNum：取同一分区内所有目录中最大的MaxBlockNum值。</li><li>Level：取同一分区内最大Level值并加1。</li></ul><p><img src="https://i.loli.net/2020/10/27/rTvLeyI6awNAgu9.png" alt="image-20201027132538594"></p><h2 id="一级索引"><a href="#一级索引" class="headerlink" title="一级索引"></a>一级索引</h2><p><img src="https://i.loli.net/2020/10/27/NegJICanu4xE3wo.png" alt="image-20201027133717459"></p><p>由于稀疏索引占用空间小，所以primary.idx内的索引数据常驻内存，取用速度自然极快。</p><p>ClickHouse对主键索引的定义和传统数据库的定义稍有不同，它的主键索引没用主键去重的含义，但仍然有快速查找主键行的能力。</p><p>ClickHouse的主键索引存储的是每一个granularity中起始行的主键值.</p><h2 id="索引查询过程"><a href="#索引查询过程" class="headerlink" title="索引查询过程"></a>索引查询过程</h2><p>MergeTree按照index_granularity的间隔粒度，将一段完整的数据划分成了多个小的间隔数据段，一个具体的数据段即是一个MarkRange。</p><p>三个步骤:</p><ul><li>生成查询条件区间</li><li>递归交集判断 如果不存在交集 剪枝算法优化整段markrange 存在交集将此区间进一步拆分成8个子区间,如果存在交集且步长小于8 则记录markrange返回.</li><li>合并markrange区间并返回</li></ul><p><img src="https://i.loli.net/2020/10/27/l1RGWoSLndmx4bK.png" alt="image-20201027140445322"></p><p>因为MarkRange转换的数值区间是闭区间，所以会额外匹配到临近的一个区间</p><h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>granularity定义了一行跳数索引能够跳过多少个index_granularity区间的数据。</p><p><img src="https://i.loli.net/2020/10/27/VWc2KZ9lUwOIrRQ.png" alt="image-20201027140918613"></p><p>跳数索引:</p><ul><li>minmax 记录了一段数据的最小最大值</li><li>set 完整形式为set(max_rows)，其中max_rows是一个阈值，表示在一个index_granularity内，索引最多记录的数据行数。如果max_rows=0，则表示无限制，<img src="https://i.loli.net/2020/10/27/GHfhaBjyILbz3RN.png" alt="image-20201027141647356"></li></ul><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p><img src="C:\Users\87028\AppData\Roaming\Typora\typora-user-images\image-20201027142825161.png" alt="image-20201027142825161"></p><p><img src="https://i.loli.net/2020/10/27/9XiFhKzpqcrVuMJ.png" alt="image-20201027143035111"></p><p>．bin文件中引入压缩数据块的目的至少有以下两个：其一，虽然数据被压缩后能够有效减少数据大小，降低存储空间并加速数据传输效率，但数据的压缩和解压动作，其本身也会带来额外的性能损耗。所以需要控制被压缩数据的大小，以求在性能损耗和压缩率之间寻求一种平衡。其二，在具体读取某一列数据时（.bin文件），首先需要将压缩数据加载到内存并解压，这样才能进行后续的数据处理。通过压缩数据块，可以在不读取整个．bin文件的情况下将读取粒度降低到压缩数据块级别，从而进一步缩小数据读取的范围。</p><h2 id="数据标记"><a href="#数据标记" class="headerlink" title="数据标记"></a>数据标记</h2><p>每一个列字段[Column].bin文件都有一个与之对应的[Column].mrk数据标记文件，用于记录数据在．bin文件中的偏移量信息。</p><p>一行标记数据使用一个元组表示，一个index_granularity对应一行标记数据. 元组内包含两个整型数值的偏移量信息。它们分别表示在此段数据区间内，在对应的．bin压缩文件中，压缩数据块的起始偏移量；以及将该数据压缩块解压后，其未压缩数据的起始偏移量。</p><p><img src="https://i.loli.net/2020/10/27/THeQr7n4j8YuxE6.png" alt="image-20201027144946353"></p><p>编号与markrange对应</p><p><img src="https://i.loli.net/2020/10/27/JK2lnFD9UrRtHEC.png" alt="image-20201027145014833"></p><h2 id="数据写入过程"><a href="#数据写入过程" class="headerlink" title="数据写入过程"></a>数据写入过程</h2><p>生成分区目录,每一批数据写入都会生成一个新的分区目录,按照index_granularity索引粒度生成一级索引,mrk,bin文件</p><p><img src="https://i.loli.net/2020/10/27/cyLad4mWg2CJH6Y.png" alt="image-20201027153053719"></p><h2 id="数据读出过程"><a href="#数据读出过程" class="headerlink" title="数据读出过程"></a>数据读出过程</h2><p><img src="https://i.loli.net/2020/10/27/TIJRo8brPM1xF73.png" alt="image-20201027153952604"></p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>ClickHouse的异步update机制。ClickHouse对update的执行是低效的，ClickHouse内核中的MergeTree存储一旦生成一个Data Part，这个Data Part就不可再更改了。所以从MergeTree存储内核层面，ClickHouse就不擅长做数据更新删除操作。ClickHouse的语法把Update操作也加入到了Alter Table的范畴中.</p><p>当用户执行一个如上的Update操作获得返回时，ClickHouse内核其实只做了两件事情：</p><ol><li>检查Update操作是否合法；</li><li>保存Update命令到存储文件中，唤醒一个异步处理merge和mutation的工作线程；先查找到需要update的数据所在datapart，之后对整个datapart做扫描，更新需要变更的数据，然后再将数据重新落盘生成新的datapart，最后用新的datapart做替代并remove掉过期的datapart。</li></ol><p>使用insert语句代替update语句。当需要对某一指定id更新数据时，就重新插入一条该id的数据.</p><p>使用MergeTree的变种AggregatingMergeTree.</p><p>AggregatingMergeTree继承自 MergeTree，存储上和基础的MergeTree其实没有任何差异，而是在数据Merge的过程中加入了“额外的合并逻辑”, AggregatingMergeTree 会将相同主键的所有行（在一个数据片段内）替换为单个存储</p><p>配合anyLast函数，替换每行数据为一种预聚合状态。其中anyLast聚合函数声明聚合策略为保留最后一次的更新数据.</p><h2 id="insert-buffer"><a href="#insert-buffer" class="headerlink" title="insert buffer"></a>insert buffer</h2><p>默认情况下,每个单独的insert到<code>MergeTree</code>都会创建一个part,存储在文件系统上是一个单独的目录中,因此,向<code>MergeTree</code>进行插入最好是通过批量插入的方式进行.</p><p>将要写的数据缓冲到RAM中，定期将其刷新到另一个表中。在读取操作中，同时从缓冲区和另一个表读取数据。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Buffer(<span class="hljs-params">database</span>, <span class="hljs-params">table</span>, <span class="hljs-params">num_layers</span>, <span class="hljs-params">min_time</span>, <span class="hljs-params">max_time</span>, <span class="hljs-params">min_rows</span>, <span class="hljs-params">max_rows</span>, <span class="hljs-params">min_bytes</span>, <span class="hljs-params">max_bytes</span>)</span><br></code></pre></td></tr></table></figure><p>如果满足所有<code>min</code>条件或至少一个<code>max</code>条件，则将数据从缓冲区中刷新并写入目标表。</p><p>在写操作期间，数据被插入到<code>num_layers</code>数目的随机缓冲区中。或者，如果要插入的数据部分足够大(大于<code>max_rows</code>或<code>max_bytes</code>)，则直接写入目标表，而省略缓冲区。</p><p>从 Buffer 表读取时，将从缓冲区和目标表（如果有）处理数据。<br>请注意，Buffer 表不支持索引。换句话说，缓冲区中的数据被完全扫描，对于大缓冲区来说可能很慢。（对于目标表中的数据，将使用它支持的索引。）</p><p>如果服务器异常重启，缓冲区中的数据将丢失。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ClickHouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉曼查酿心人剧评</title>
    <link href="/2020/12/25/%E6%8B%89%E6%9B%BC%E6%9F%A5%E9%85%BF%E5%BF%83%E4%BA%BA/"/>
    <url>/2020/12/25/%E6%8B%89%E6%9B%BC%E6%9F%A5%E9%85%BF%E5%BF%83%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/26/sA1recgftJ7VuX6.jpg" alt="d4fd92bd8104c4b6c99d7c0c67930ae"></p><p>第一次去看这种环境话剧,一开始还很期待环境话剧的演出形式.  不像是观众在台下,演员在台上的那种传统演出形式.  演员和观众有了更多的互动, 观众也随着演出的转场而移步换景, 好像剧中的故事真的就发生在自己周围, 沉浸感十足.</p><p>拉曼查是西班牙的葡萄酒产区,故事也主要发生在这个地方. 辛雨追寻男朋友路涛的脚步来到了西班牙,然而却和路涛产生了矛盾. 后来房东姐姐过来安慰辛雨,并帮她安排了在拉曼查采摘葡萄的”高薪工作”. 其实在这里就可以大概猜出路涛的退缩可能就是因为房东丽娜. 后来,辛雨来到拉曼查,邂逅了罗蒙,在拉曼查的生活让辛雨逐渐和过去的自己和解,和路涛和解. 葡萄酿酒,拉曼查酿心. 最后辛雨接受了罗蒙的追求,留在了西班牙,留在了拉曼查.</p><p><img src="https://i.loli.net/2020/12/26/vrfkxd6uq29bwIz.jpg" alt="b9c42b5aeaf3d86d81416418b69437d"></p><p>故事比较简单,其中的许多细节都很用心.比如现场的环境布置, 跟着演员一起走过他们在马德里的屋子,坐着前往拉曼查的火车,到拉曼查的酒庄,都有一种身临其境的感觉. 其中一幕是观众隔着窗户和百叶窗在看,虽然听不到演员的对白,我站的比较靠后也没看到他们在屋子里发生了什么.但这就给观众一种置身其中而又旁观的感觉.还有在从马德里到拉曼查的路上,手电筒的光打在积木上,手电筒缓缓移动,在墙上打出火车行进的光影,特别惊喜.中间还穿插的很多的吉他,钢琴演奏还有歌舞.虽然我不太喜欢太多的歌舞元素,可能还是比较喜欢讲故事多一点吧.</p><p>ps: clickhouse在圣诞节的彩蛋,后面应该会写clickhouse的内容啦.</p><p>Happy new year.</p><p><img src="https://i.loli.net/2020/12/26/vioFQObKH5h7S3N.png" alt="f83fca24b7371cd9d257914514c3ebf"></p>]]></content>
    
    
    
    <tags>
      
      <tag>戏剧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用命令(3)</title>
    <link href="/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(3)/"/>
    <url>/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(3)/</url>
    
    <content type="html"><![CDATA[<p>这次主要写一些数学相关的东西.</p><hr><p>在LaTeX中最常用到的就是文本模式和数学模式.数学模式又分为行内公式和行间公式两种.</p><p>简单来说,行内公式就是将数学式子写在文本行中,与文本融为一体,适用于比较简单的式子,比如说: <img src="https://www.zhihu.com/equation?tex=a%5E2+b%5E2=c%5E2" alt="[公式]"> .</p><p>而行间公式是将数学式插在文本行之间,自成一行.适用于较复杂的式子.</p><p>行内公式的三种形式</p><ul><li>$…….$</li><li>(…….)</li><li>\begin{math}……..\end{math}</li></ul><p>排版效果都相同,我一般使用第一种方法.</p><p>行间公式的三种形式</p><ul><li>$$……..$$</li><li>[……….]</li><li>\begin{displaymath}…..\end{displaymath}</li></ul><p>排版效果都相同,我一般使用第一种或第二种方法.</p><p>除此之外,还可以使用equation公式环境,会自动生成带序号的行间公式.</p><p>数学相关的宏包比较多,一般来说,公式宏包amsmath和字符宏包amssymb是最常用的.</p><p><strong>常用数学符号</strong></p><p>这里偷个懒,用一下刘海样老师的《LaTeX入门》中整理的数学符号。</p><p><img src="https://pic1.zhimg.com/80/v2-ccda495fa31337b40f2621cc43f91234_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-57501edad60547ac7caeedde28649960_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-42210e5e4377b1a88983b254c506327a_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-710f0732753a1b2226612ede151bcdf3_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-c588ef9e531c12e3fc0cda3ca9884875_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-d59db9aaa09c749eb6cf54e2f8e0def3_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-e8d8c9a5dfb8ebae49a285a424aea0d2_720w.jpg" alt="img"></p><p>同时如果遇到不会打的符号可以通过<a href="http://detexify.kirelabs.org/classify.html">这个</a>网站手写查询。</p><p>\boldmath 用来加粗数学符号，如向量。需用在数学模式之外。例：\boldmath$\alpha$</p><p>斜体大写希腊字母：\mathnormal</p><p>粗斜体希腊字母：\boldsymbol</p><p>空心大写字母：\mathbb</p><p>公式中如果需要文字可以使用\text{文字}，将文字插入公式中。</p><p>\frac 与\dfrac</p><p>\frac生成的公式会在高度上压缩，\dfrac可以避免这个问题。</p><p>实例图如下</p><p><img src="https://pic1.zhimg.com/80/v2-baf4a635dee001d47e0fcd15af6be6d8_720w.jpg" alt="img"></p><p>上下标：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\sum_&#123;i=1&#125;^&#123;n&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-be129ea3fea5f7b44f600cba5203c507_720w.jpg" alt="img"></p><p>多行上下标：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$\lim\limits_&#123;\substack&#123;P\to P_0\\P\in D&#125;&#125;f(P)=f(P_0)$$<br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-82cb750d832ad886665b9a0afe7e31f5_720w.jpg" alt="img"></p><p>数学中的表格环境之前有介绍到，这里就不重复了。<a href="https://zhuanlan.zhihu.com/p/35041879">LaTeX-我的常用命令(2)</a></p><p>定理环境：</p><p>需要先使用定义定理类环境的命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\newtheorem&#123;环境名&#125;[]&#123;标题&#125;[]<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">\newtheorem&#123;defi&#125;&#123;定义&#125;<br>\begin&#123;defi&#125;<br>$a^2+b^2=c^2$<br>\end&#123;defi&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-4dd330bed972976bb98583e69c17c940_720w.jpg" alt="img"></p><p>数学模式中的空白</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">\quad<br>\qquad<br>\,%大小约为3/18个\quad<br>\;%5/18\quad<br>\:%4/18\quad可用于对空白的控制<br></code></pre></td></tr></table></figure><p>自适应的放大命令</p><p>可根据内容自动放大括号</p><p>示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">\left(\drac&#123;\frac ab +c&#125;&#123;d&#125;\right)<br>%如果只出现左半边括号，也需要在另一端加\right.<br></code></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-f0b53419bc0f01609f5507debf855cf6_720w.jpg" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用命令(2)</title>
    <link href="/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(2)/"/>
    <url>/2020/12/24/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(2)/</url>
    
    <content type="html"><![CDATA[<p>这是第二篇,主要写一下表格,列表,图的内容,还有上次没写到的参考文献.</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>LaTeX提供了无表格框线环境tabbing和有表格框线的tabular,tabular*,array,其中array是用于数学模式的表格环境.</p><p>就我个人而言,主要使用tabular,array这两种表格环境.</p><p>先来介绍<strong>tabular</strong></p><p>tabular的命令结构如下:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">\begin&#123;tabular&#125;[位置]&#123;列格式&#125;<br>内容&amp; 内容&amp;&#x2F;&#x2F; %其中&amp; 表示分隔 ,&#x2F;&#x2F;表示换行<br>\end&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>其中’位置’为可选参数,</p><p>‘列格式’可以设置表格中数据的对齐方式,列宽,列间距等</p><ul><li>l 左对齐</li><li>c 居中对齐</li><li>r 右对齐</li><li>| 画一条垂直线</li><li>|| 画两条垂直线</li><li>{n}{列格式} 用n次列格式 ,举例: *{3}{|c}相当于输入 |c|c|c</li><li>@{声明} 它会将侧边与列之间的空白或是列与列之间的空白删除插入声明的内容</li></ul><p><strong>合并单元格</strong></p><p>\cline{i-j}可以从第i列的左侧到第j列的右侧画一条线.</p><p>\hline 画一条与列表宽度相同的水平线</p><p>如果要合并行需要使用multirow 宏包,</p><p>\multirow{n}*{内容} 表示合并n行以’内容’填充其中.</p><p>\multicolumn{n}{列格式}{内容}表示合并n列,以’内容’填充,列格式与前面介绍的相同.下面举个例子来说明.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;multirow&#125;<br>\begin&#123;document&#125;<br>\begin&#123;tabular&#125;&#123;||c|c|c|c||&#125;<br>\hline<br>\multirow&#123;2&#125;*&#123;合并行&#125;&amp;\multicolumn&#123;3&#125;&#123;c||&#125;&#123;合并列&#125;\\<br>\cline&#123;2-4&#125;<br>&amp;测试&amp;测试&amp;测试\\<br>\hline<br>\end&#123;tabular&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-b1e312ddae0b39778eee21af6ef80a31_720w.jpg" alt="img"></p><p><strong>array</strong></p><p>array需要使用宏包array</p><p>array的命令结构如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;array&#125;[位置]&#123;列格式&#125;<br>内容&amp; 内容&amp;// %其中&amp; 表示分隔 ,//表示换行<br>\end&#123;array&#125;<br></code></pre></td></tr></table></figure><p>可以看到与tabular完全相同,array就是在数学模式中的表格环境.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;array&#125;<br>\begin&#123;document&#125;<br>\begin&#123;equation&#125;<br>\left\&#123;<br>\begin&#123;array&#125;&#123;*&#123;3&#125;&#123;l@&#123;+&#125;&#125;l@&#123;=&#125;l&#125;<br>a_&#123;11&#125;x_&#123;1&#125;&amp;a_&#123;12&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;1n&#125;x_n&amp;c_1\\<br>a_&#123;21&#125;x_&#123;1&#125;&amp;a_&#123;22&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;2n&#125;x_n&amp;c_2\\<br>a_&#123;i1&#125;x_&#123;1&#125;&amp;a_&#123;i2&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;in&#125;x_n&amp;c_i\\<br>a_&#123;m1&#125;x_&#123;1&#125;&amp;a_&#123;m2&#125;x_&#123;2&#125;&amp;\cdots&amp;a_&#123;mn&#125;x_n&amp;c_m\\ <br>\end&#123;array&#125;\right.<br>\end&#123;equation&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-ebac80d794b8c4c05496e75ccea1cdfc_720w.jpg" alt="img"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表环境有itemize,enumerate和description</p><p>itemize相当于无序列表,enumerate相当于有序列表</p><p>itemize的命令结构如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;itemize&#125;<br>\item[标志] 条目<br>\end&#123;item&#125;<br></code></pre></td></tr></table></figure><p>标志默认是实心大圆点,可以更改为其他标志,示例如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;itemize&#125;<br>\item 第一条测试<br>\item[$\rightarrow$] 第二条测试<br>\end&#123;itemize&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-a276dfdc63a147ce4a75f5cb4b90bba6_720w.jpg" alt="img"></p><p>排序列表enumerate前面的标号默认是1,2,3….,不再赘述</p><h2 id="图形插入"><a href="#图形插入" class="headerlink" title="图形插入"></a>图形插入</h2><p>插图需使用graphics宏包</p><p>常用的插图命令为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\includegraphics[参数1=选项,...]&#123;图名&#125;<br></code></pre></td></tr></table></figure><p>下面介绍一下常用的参数</p><ul><li>height 插图的高度</li><li>width 插图的宽度</li><li>scale 相比于原图缩放系数</li><li>angle 正值表示逆时针旋转,负值表示顺时针旋转</li></ul><p>当把图插入段落中时需使用figure环境,示例如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;figure&#125;[htbp]%<br>\centering<br>\includegraphics [scale=0.6]&#123;test.jpg&#125;<br>\caption&#123;测试&#125;%标题<br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><blockquote><p>『h』当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩的页面不够，这一参数将不起作用。<br>『t』顶部。将图形放置在页面的顶部。<br>『b』底部。将图形放置在页面的底部。<br>『p』浮动页。将图形放置在一只允许有浮动对象的页面上。</p></blockquote><p>当我们需要两个或多个图并排排列时,需使用minipage环境,示例如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;figure&#125;[htbp]<br>\centering<br>\begin&#123;minipage&#125;[c]&#123;0.5\textwidth&#125;<br>\centering<br>\includegraphics[width=0.3\textwidth]&#123;test.jpg&#125;<br>\caption&#123;测试1&#125;<br>\end&#123;minipage&#125;%<br>\begin&#123;minipage&#125;[c]&#123;0.5\textwidth&#125;<br>\centering<br>\includegraphics[width=0.3\textwidth]&#123;test.jpg&#125;<br>\caption&#123;测试2&#125;<br>\end&#123;minipage&#125;<br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>参考文献可以使用环境thebibliography,</p><p>thebibliography的命令结构如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">\begin&#123;thebibliography&#125;&#123;最宽序号&#125;<br>\bibitem[文献序号1]&#123;检索名1&#125; 文献信息1<br>\end&#123;thebibliography&#125;<br></code></pre></td></tr></table></figure><p>通常用99为最宽序号</p><p>文献序号用于设置文献在参考文献中的序号,可以不填,默认为按顺序的阿拉伯数字</p><p>检索名用于正文中的引用</p><p><strong>引用命令</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">\cite&#123;检索名1,检索名2...&#125;<br></code></pre></td></tr></table></figure><p>在参考文献较少时可以使用thebibliography环境,为了更好的管理文献可以使用BibTeX,文献管理程序.</p>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用命令(1)</title>
    <link href="/2020/12/23/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(1)/"/>
    <url>/2020/12/23/LaTeX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(1)/</url>
    
    <content type="html"><![CDATA[<p>这一篇主要记录自己常用的一些LaTeX的操作,包括常用的一些格式,下一节LaTeX文章主要为数学公式及图表的内容.</p><h2 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h2><p>一般来说,我们写TeX文档时,第一句命令就是文档类型的命令.</p><p>文档类型主要有 article,report,book,beamer,还有用于中文排版的ctexart,ctexrep,ctexbook分别对应article,report,book.用于排版中文的文类可以不用再调用ctex宏包直接使用中文.而且文档中的图,表,日期等都是中文显示.一般写一些课程小论文用ctexart就可以.</p><h2 id="标题页"><a href="#标题页" class="headerlink" title="标题页"></a>标题页</h2><p>LaTeX中提供了一组题名的命令,可以用于生成标题页的题名,作者,日期等内容.</p><p>以下命令写在导言区中.</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">\title&#123;论文&#125;%论文题名<br>\author&#123;作者&#125;%作者姓名<br>%\<span class="hljs-keyword">date</span>&#123;&#125;%日期<br></code></pre></td></tr></table></figure><p>如果不设置日期,将默认是今天的日期.</p><p>在正文中</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\maketitle</span><br></code></pre></td></tr></table></figure><p>将会自动生成默认格式的标题页</p><p><img src="https://pic4.zhimg.com/v2-c1cd03a4f65d8a0900d7c82d5a61f613_b.jpg" alt="img"></p><p>一般写一些课内小论文之类的直接用默认格式,如果要写论文或是毕业论文之类比较正式的文档就可以使用模板.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">\<span class="hljs-selector-tag">thanks</span>&#123;&#125;%添加脚注,对题名的说明或是作者简介之类.<br></code></pre></td></tr></table></figure><p>article默认题名与正文相连,不单独设页,book,report则会创建单独的一页.</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一般在正文前都有摘要,在文档类article,ctexart中都提供了摘要环境</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">\<span class="hljs-keyword">begin</span>&#123;<span class="hljs-keyword">abstract</span>&#125;<br>内容<br>\<span class="hljs-keyword">end</span>&#123;<span class="hljs-keyword">abstract</span>&#125;<br></code></pre></td></tr></table></figure><p>该环境会默认生成粗体字居中的摘要标题.</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>在正文之前使用命令</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\tableofcontents</span><br></code></pre></td></tr></table></figure><p>就可以生成默认格式的目录,如果对默认的目录格式不满意可以使用titletoc宏包修改目录的格式.</p><p>目录格式命令</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">\titlecontents</span><span class="hljs-template-variable">&#123;标题名&#125;</span><span class="xml">[左间距]</span><span class="hljs-template-variable">&#123;标题格式&#125;</span><span class="hljs-template-variable">&#123;标题标志&#125;</span><span class="hljs-template-variable">&#123;无序号标题&#125;</span><span class="hljs-template-variable">&#123;指引线与页码&#125;</span><span class="xml">[下间距]</span><br></code></pre></td></tr></table></figure><p>下面是我使用的目录页设置命令</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\t</span>itlecontents&#123;section&#125;[0em]&#123;<span class="hljs-symbol">\z</span>ihao&#123;4&#125;<span class="hljs-symbol">\b</span>f &#125;&#123;<span class="hljs-symbol">\t</span>hecontentslabel<span class="hljs-symbol">\ </span>&#125;&#123;&#125;<br>&#123;<span class="hljs-symbol">\h</span>space&#123;.5em&#125;<span class="hljs-symbol">\t</span>itlerule*[4pt]&#123;$<span class="hljs-symbol">\c</span>dot$&#125;<span class="hljs-symbol">\c</span>ontentspage&#125;<br><span class="hljs-symbol">\t</span>itlecontents&#123;subsection&#125;[2em]&#123;<span class="hljs-symbol">\v</span>space&#123;0.1<span class="hljs-symbol">\b</span>aselineskip&#125;<span class="hljs-symbol">\z</span>ihao&#123;-4&#125;&#125;&#123;<span class="hljs-symbol">\t</span>hecontentslabel<span class="hljs-symbol">\ </span>&#125;&#123;&#125;<br>&#123;<span class="hljs-symbol">\h</span>space&#123;.5em&#125;<span class="hljs-symbol">\t</span>itlerule*[4pt]&#123;$<span class="hljs-symbol">\c</span>dot$&#125;<span class="hljs-symbol">\c</span>ontentspage&#125;<br><span class="hljs-symbol">\t</span>itlecontents&#123;subsubsection&#125;[4em]&#123;<span class="hljs-symbol">\v</span>space&#123;0.1<span class="hljs-symbol">\b</span>aselineskip&#125;<span class="hljs-symbol">\z</span>ihao&#123;-4&#125;&#125;&#123;<span class="hljs-symbol">\t</span>hecontentslabel<span class="hljs-symbol">\ </span>&#125;&#123;&#125;<br>&#123;<span class="hljs-symbol">\h</span>space&#123;.5em&#125;<span class="hljs-symbol">\t</span>itlerule*[4pt]&#123;$<span class="hljs-symbol">\c</span>dot$&#125;<span class="hljs-symbol">\c</span>ontentspage&#125;<br></code></pre></td></tr></table></figure><h2 id="页眉页脚"><a href="#页眉页脚" class="headerlink" title="页眉页脚"></a>页眉页脚</h2><p>LaTeX中有4种页眉页脚的版式</p><ol><li>empty 页眉页脚都空置</li><li>plain 页眉空置,页脚中间是页码,无页脚线</li><li>headings 偶数页页眉左端是页码,右端是章标题;奇数页页眉的右端是页码,左端是节标题,是book类的默认格式</li><li>myheadings 格式与headings基本相同,左页页眉的右端和右页页眉的左端空置</li></ol><p>使用命令\pagestyle{}设置版式,使用\thispagestyle{}设置当前页的格式,页码一般从正文开始,所以正文前的页一般要设置为empty版式,</p><p>如果需要自己设置页码页眉的格式可以用fancyhdr宏包.</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">\<span class="hljs-variable">fancyhead</span><span class="hljs-punctuation">[</span>参数<span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#123;</span>页眉内容<span class="hljs-punctuation">&#125;</span><br>\<span class="hljs-variable">fancyfoot</span><span class="hljs-punctuation">[</span>参数<span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#123;</span>页眉内容<span class="hljs-punctuation">&#125;</span><br><span class="hljs-operator">%</span>参数选项可以为<span class="hljs-variable">EL</span><span class="hljs-operator">,</span><span class="hljs-variable">EC</span><span class="hljs-operator">,</span><span class="hljs-variable">ER</span><span class="hljs-operator">,</span><span class="hljs-variable">OL</span><span class="hljs-operator">,</span><span class="hljs-variable">OC</span><span class="hljs-operator">,</span><span class="hljs-variable">OR</span>其中<span class="hljs-built_in">E</span>代表左页<span class="hljs-operator">,</span><span class="hljs-built_in">O</span>代表右页<span class="hljs-operator">,</span><span class="hljs-variable">L</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">R</span>分别代表左<span class="hljs-operator">,</span>中<span class="hljs-operator">,</span>右<br></code></pre></td></tr></table></figure><p>目录页的设置可以参考<a href="http://www.ctex.org/PackageCTeX/">这里</a></p><h2 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h2><p>需使用listings宏包,使用lstset在导言区配置,</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">\lstset&#123;<br><span class="hljs-attribute">numbers</span>=left,  <br><span class="hljs-attribute">frame</span>=tb,<br><span class="hljs-attribute">aboveskip</span>=3mm,<br><span class="hljs-attribute">belowskip</span>=3mm,<br><span class="hljs-attribute">showstringspaces</span>=<span class="hljs-literal">false</span>,<br><span class="hljs-attribute">columns</span>=flexible,<br><span class="hljs-attribute">framerule</span>=1pt,<br><span class="hljs-attribute">rulecolor</span>=\color&#123;gray!35&#125;,<br><span class="hljs-attribute">backgroundcolor</span>=\color&#123;gray!5&#125;,<br>basicstyle=&#123;\ttfamily&#125;,<br><span class="hljs-attribute">numberstyle</span>=\tiny\color&#123;gray&#125;,<br><span class="hljs-attribute">keywordstyle</span>=\color&#123;blue&#125;,<br><span class="hljs-attribute">commentstyle</span>=\color&#123;dkgreen&#125;,<br><span class="hljs-attribute">stringstyle</span>=\color&#123;mauve&#125;,<br><span class="hljs-attribute">breaklines</span>=<span class="hljs-literal">true</span>,<br><span class="hljs-attribute">breakatwhitespace</span>=<span class="hljs-literal">true</span>,<br><span class="hljs-attribute">tabsize</span>=3,<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是我的代码环境设置,可以参考.</p><p>在需要插入代码的时候</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">\<span class="hljs-built_in">begin</span>&#123;lstlisting&#125;[language=C++,escapeinside=``]<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> main<br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Hello world!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//`输出`</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>\<span class="hljs-built_in">end</span>&#123;lstlisting&#125;<br></code></pre></td></tr></table></figure><p>其中如果需要使用中文需要逃逸环境.</p><p>显示效果如下:</p><p><img src="https://pic3.zhimg.com/v2-32d7e95010dac6872d14c370040b9e62_b.jpg" alt="img"></p><h2 id="其他一些想到的"><a href="#其他一些想到的" class="headerlink" title="其他一些想到的"></a>其他一些想到的</h2><p>geometry宏包可以改变页边距</p><p>使用如下:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">\usepackage[a4paper,<span class="hljs-keyword">left</span>=<span class="hljs-keyword">cm</span>,<span class="hljs-keyword">right</span>=<span class="hljs-keyword">cm</span>,top=<span class="hljs-keyword">cm</span>,bottom=<span class="hljs-keyword">cm</span>]&#123;geometry&#125;<br></code></pre></td></tr></table></figure><p>脚注:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">\footnote</span><span class="hljs-template-variable">&#123;文字&#125;</span><br></code></pre></td></tr></table></figure><p>间距调整</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">\<span class="hljs-attr">vspace&#123;1</span>cm&#125;<span class="hljs-meta">%</span>水平间距调整<br>\<span class="hljs-attr">vskip 7</span>cm <span class="hljs-meta">%</span>垂直间距调整<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>packed memory arrays-rewired</title>
    <link href="/2020/12/14/packed%20memory%20arrays-rewired/"/>
    <url>/2020/12/14/packed%20memory%20arrays-rewired/</url>
    
    <content type="html"><![CDATA[<h1 id="packed-memory-arrays-rewired"><a href="#packed-memory-arrays-rewired" class="headerlink" title="packed memory arrays-rewired"></a>packed memory arrays-rewired</h1><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="a-b-tree"><a href="#a-b-tree" class="headerlink" title="(a,b)-tree"></a>(a,b)-tree</h2><p>(a,b)-tree是一个平衡的(所有的叶子在同一层)搜索树，</p><ul><li>2≤a≤(b+1)/2,当a==(b+1)/2时 为b-tree</li><li>根结点最多有b个子结点。</li><li>除了根节点之外，每个内部节点至少有a个子节点，最多有b个子节点。</li><li>所有从根到叶的路径都是相同的长度。</li></ul><p>(2,3)-tree 是b树 (a,b)-tree相当于b-tree的扩展,b-tree是(a,b)的特例. </p><p><a href="https://cs.lmu.edu/~ray/notes/abtrees/">https://cs.lmu.edu/~ray/notes/abtrees/</a></p><p><a href="https://en.wikipedia.org/wiki/(a,b)-tree">https://en.wikipedia.org/wiki/(a,b)-tree</a></p><h2 id="传统-PMAa"><a href="#传统-PMAa" class="headerlink" title="传统 PMAa"></a>传统 PMAa</h2><p>一个数组，其中的元素是按照排序的顺序存储的，交叉元素或间隙。间隙的目的是提供额外的空间，以便在数组的任意位置插入新元素，而不需要移动现有元素的长序列来维持排序顺序。</p><h3 id="PMA的实现"><a href="#PMA的实现" class="headerlink" title="PMA的实现"></a>PMA的实现</h3><p>搜索数组中的元素可以通过二分搜索利用排序顺序来实现。范围扫描包括在范围的两个端点之间对数组进行顺序迭代。这里，空槽被简单地忽略。要插入新元素，算法首先在数组中搜索它的目标槽。但是，如果该位置已经被另一个元素e占据，则算法首先将e和e的所有相邻元素移向数组中最接近的间隙。最后，要删除数组中的元素，算法只需将其槽标记为空。</p><p>在部分数据变得过于稀疏或过于密集时，在本地重新调整数据结构。</p><ol><li>定位要插入元素的位置。我们要么事先知道这个，要么执行代价为O(log2N)的二分查找。</li><li>如果我们要插入的单元格是空闲的，我们只需添加元素，并将该单元格标记为used。</li><li>但是，如果要插入的单元格被使用了，我们计算所需单元格所在的最小块(大小为log N)的上限密度阈值，并检查是否会违反上限密度阈值。如果我们注意到没有超过阈值，我们只需重新平衡所有元素，包括新的元素到那个块中。如果我们违反了较高的密度阈值，我们考虑一个两倍大的块(其中包括我们将插入的单元格)，并检查是否违反了密度阈值。我们不断向上移动，直到找到一个不违反上密度阈值的块。</li><li>如果我们找不到这样的块，我们就分配一个两倍大的数组，并整齐地将所有现有的元素复制到新的数组中，元素之间的间隔是恒定的.</li></ol><h3 id="APMA"><a href="#APMA" class="headerlink" title="APMA"></a>APMA</h3><p>hammering 敲打指的是连续且频繁的插入发生在数组的相同区域。</p><p>在hammering发生的段放置更多的gap,但也可能会出现乒乓效应,性能甚至不如传统PMA.</p><p><img src="https://i.loli.net/2020/10/31/3lUX82qmFJyBtip.png" alt="image-20201031194615762"></p><p>如图所示,最后插入的是14,15,16.apma认为在第一段中插入数据过多,于是在rebalance的过程中在第一段中放置更多的gap,但是实际上的插入序列如果是17,18,19,则性能可能会很差.</p><h3 id="Calibrator-tree"><a href="#Calibrator-tree" class="headerlink" title="Calibrator tree"></a>Calibrator tree</h3><p><img src="https://i.loli.net/2020/11/08/rug3HlaGUioPILm.png" alt="image-20201108164808490"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>基于树的索引结构的物理内存布局会随着时间的推移而恶化(比如B-树中的合并与分裂),物理级别上的顺序扫描就会变成非顺序的，因此扫描操作会变慢.Packed Memory Arrays(PMA)通过管理所有数据在一个顺序稀疏阵列来防止顺序扫描变成非顺序的。本文在PMA的基础上提出了一个改进的数据结构:Rewired Memory Array(RMA)。RMA可以达到具有竞争力的更新和点查找性能，同时始终提供优越的扫描性能-接近密集列扫描。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>针对列存存储引擎,本文提出了一种基于PMA的数据结构。列存变得稀疏而不是密集。在存储的元素中有空的间隙，以适应未来可能的更新。因此，可以直接就地执行更新。扫描是顺序的，比(a,b)-tree快. 更新可以在对数复杂度完成，但比不上(a,b)-tree。</p><p><img src="https://i.loli.net/2020/11/08/8FaG4lIwVOip7PD.png" alt="image-20201108124846773"></p><p>有几个因素会阻碍稀疏数组的性能。对于扫描，通过检查数组的每个插槽是否被填满，需要付出大量的CPU 代价。对于更新，数据结构偶尔需要重新平衡，这增加了这些操作的平均成本。此外，在重新平衡期间，数组中的元素可能会被移动，这也会导致PMAs的索引分隔符键的更新.(索引存储每个段的最小key).在存在数据倾斜的情况下，稀疏数组会遇到最坏的情况，并且在更新期间会进行更多的内部重组.</p><h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ul><li>通过提出cluster、固定大小的段、静态索引和内存重布线，克服了scan的一些性能问题，同时减少了内部重平衡的延迟。</li><li>对自适应再平衡进行了改进。自适应再平衡减少了出现更新倾斜时发生的再平衡数量。尽管如此，我们还是发现了APMA的自适应再平衡策略是有害的，并提出了一种新的算法，解决了它的局限性。</li><li>提出了一种新的批量装载算法。它特别适合流场景，其中数组的基数保持不变，并且定期分批执行具有相同插入和删除数量的更新。</li></ul><h2 id="RMA"><a href="#RMA" class="headerlink" title="RMA"></a>RMA</h2><p>RMA的目的是提供快速的面向列的扫描，同时在更新方面接近(a, b)树。</p><h3 id="segments"><a href="#segments" class="headerlink" title="segments"></a>segments</h3><p>段的大小是固定的，不依赖于数据结构的当前基数或容量,将段大小绑定到I/O模型的块大小O(B)，</p><p>cluster:将长序列的元素放在一起,将长序列的间隔放在一起.</p><p>在每个槽，扫描需要检查它是否为空。为了避免检查槽是否为空，我们在一个名为cards的数组中跟踪每个段的当前基数。我们把所有的元素放在片段的一端，把间隙放到另一端。奇数段将元素放在右边,偶数段将元素放在左边.</p><p>扫描对每两个片段的密集值序列执行一个紧循环。(在两个段内进行二分?)</p><p>RMAs非常像(a, b)树。实际上，组成数组的段类似于(a, b)树的叶节点。</p><p>(a, b)树在更新中有优势，而稀疏数组在扫描中有优势。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>RMAs维护一个静态索引以改进点查找和更新。它是静态的，在RMA调整大小后构建，它包含固定数量的条目。尽管如此，单个条目还是可以改变的，在再平衡期间就会发生。索引只有分隔符键被存储，打包在一个连续的数组中。节点遍历是通过计算节点与数组中当前位置的偏移来执行的</p><p><img src="https://i.loli.net/2020/11/08/mv9RHA1MGEOdJD3.png" alt="image-20201108135554072"></p><p>根节点包含r分隔符键，和r + 1个孩子,最左边的r个子树是高度为h - 1的满子树.槽的内容是相关段的分隔键.</p><h3 id="re-balancing"><a href="#re-balancing" class="headerlink" title="re-balancing"></a>re-balancing</h3><p>rebalance包含两个过程,第一个过程中,将元素移动和压缩到间隔的右端或辅助附加存储中。在第二个过程中，继续前进，将元素复制到它们在数组中的最终位置。如果重新平衡的间隔小于虚拟页，我们的解决方案仍然遵循这种方案。否则，我们直接将元素从数组的页面移动并直接展开，以将parray重新平衡为一组未使用的物理页面pbuffer。最后，我们在parray和pbuffer之间一个一个地交换虚拟地址。这种技术的优点是它只对每个元素执行一次复制，而不是两次。</p><p><img src="https://i.loli.net/2020/11/08/X8KJVozAfnjyevb.png" alt="image-20201108143530259"></p><p>除了RMA使用的空间之外，我们还维护了一组按需分配的备用缓冲区。在重新平衡时，元素被重新分配到缓冲区空间中(参见图6b)。然后，使用内存重新连接，来自缓冲区的页面成为阵列的一部分，而阵列的旧物理页面成为备用缓冲区，以便在未来重新平衡时重用(参见图6c)。</p><p>在RMA当前使用的存储之后是备用缓冲区的物理页面(如图6a所示)。当需要扩展RMA时，我们吸收RMA中现有的备用缓冲区。如果需要缩小RMA，我们将RMA结束时释放的页面吸收到缓冲区中。好处是减轻从操作系统获取新的物理页面的开销.</p><h3 id="bulk-loading"><a href="#bulk-loading" class="headerlink" title="bulk loading"></a>bulk loading</h3><p>避免在单个批处理中对相同的段进行多次再平衡。</p><p>自顶向下的策略:假设批处理中的元素已经预先排序，关键思想是从根开始遍历校准器树，然后递归地将输入序列传播给子元素。但是，如果给定节点的阈值不能满足，算法将触发再平衡，将输入序列与当前窗口中的现有元素合并。缺点是可能会造成额外的rebalance,因为顶部的阈值比较小.</p><p>自底向上的策略:首先，对插入的输入序列S进行排序。然后，该算法分三次运行。在第一次遍历中，它扫描S，只改变将插入元素的每个段的最终基数。在第二步中，它扫描被插入的片段，检查阈值是否被遵守。如果没有，它确定需要重新平衡的段间隔。最后，它对被插入的片段进行第三步。如果一个段没有标记进行再平衡，它就简单地插入来自S的相关元素,否则,rebalance第二步中的段间隔,合并相关的现有元素与排序后的序列S. 该方法可以扩展到批量插入和删除。</p><h3 id="kv分离"><a href="#kv分离" class="headerlink" title="kv分离"></a>kv分离</h3><p>改进了点查找，因为查找特定键需要遍历的内存空间更少了。</p><h3 id="自适应-re-balancing"><a href="#自适应-re-balancing" class="headerlink" title="自适应 re-balancing"></a>自适应 re-balancing</h3><p>采用自适应再平衡来减少锤击带来的未来再平衡的数量。自适应策略被分为两个不同的部分。在第一部分中，在每次插入时，会在一个名为Detector的自定义数据结构中收集一些额外的元数据。第二部分是实际的再平衡机制，其中检查收集的元数据，以确定数组中元素的重新分布。其核心算法是递归的自适应算法。它从当前calibrator子树的顶部开始，在每一步中，它将确定分配到其子节点上的元素的数量。</p><p><img src="https://i.loli.net/2020/10/31/bPMGxNy9Unr4pDz.png" alt="image-20201031200041751"></p><p><img src="https://i.loli.net/2020/10/31/9KoMQU6nFLWP3iC.png" alt="image-20201031200641386"></p><h3 id="detector"><a href="#detector" class="headerlink" title="detector"></a>detector</h3><p>算法1是用于更新片段s元数据的代码，在每次插入数据之后调用。它首先在Q中记录当前操作的时间戳。时间戳可以通过某个离散的全局计数器或CPU时间戳计数器获得。此外，它还检查正在插入的键k的后继或前驱是否分别匹配kbwd或kfwd。如果两个键中有一个匹配，相关的计数器增加1，直到最大阈值SC。否则，两个计数器都减少1。当计数器达到0时，相关的kbwd和kfwd值被succk和predk替换</p><p>与kbwd关联的值3意味着，在最近的插入中，刚刚插入的键的后继至少有3次是19。因此，算法可能会猜测，未来新的插入很可能在这个范围内[predecessor(19)， 19]。</p><p><img src="https://i.loli.net/2020/11/08/rsqHA8uc6JOZFdL.png" alt="image-20201108151101780"></p><h3 id="自适应算法"><a href="#自适应算法" class="headerlink" title="自适应算法"></a>自适应算法</h3><p>自适应算法对传统的TPMA再平衡过程进行了整合和扩充。与TPMA一样，整个过程的第一步是找到重新平衡的窗口。该操作通过遍历和验证校准树的密度阈值来完成。第二步，称为预处理阶段，包括产生一组有标记的间隔，利用检测器中的信息。如果没有创建标记间隔，则按照TPMA中的方法进行再平衡过程.否则，第三步是实际的自适应算法。该算法自顶向下遍历calibrator树，确定要放置在每个子节点上的元素数量，传输基数最小的节点中标记的间隔。这一步的输出是W中所有段的目标基数。在自适应算法的执行过程中，数组中的任何元素都不会被物理复制。只有在其结束时，当W中所有段的目标基数已经确定时，元素才会在数组中重新分布。</p><p>标记一些最近有更新的段。如果其段关联的计数器大于给定的阈值，则会发出带有kbwd或kfwd的大小为2的间隔.</p><p>自适应算法是自顶向下遍历校准器子树，根在W.</p><p>objective function 尝试将相同数量的标记间隔重新分配给每个子节点。如果不能做到这一点，例如 只有一个间隔 其余标记的间隔被移动到基数最小的子节点</p><p><img src="https://i.loli.net/2020/11/08/JHCdTKugaA9m7oN.png" alt="image-20201108193201610"></p><p>在继续进行下一个递归级别之前，可能需要增加或者减少节点的目标基数。如果一个孩子v的元素密度小于其较低的阈值，那么它就会尽可能多地从其兄弟姐妹那里借用元素，从而使元素密度大于给定阈值.</p><p><img src="https://i.loli.net/2020/11/02/Gz8yB57mYSNxIJA.png" alt="image-20201102205433999"></p>]]></content>
    
    
    
    <tags>
      
      <tag>paper reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/12/hello-world/"/>
    <url>/2020/12/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
